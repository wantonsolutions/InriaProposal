\section{Intro}
\label{sec:intro}

Building large scale distributed systems is challenging. Rather than face the
headaches of coordinating thounds of machines by hands, developers use
frameworks which hide the
complexity~\cite{Dean:2008:MSD:1327452.1327492,Zaharia:2012:RDD:2228298.2228301,Murray_naiad:a}.
These frameworks sacrifice performance for generality and
simplicity~\cite{McSherry:2015:SBC:2831090.2831104}. Recent work has
demontrated that some tasks benfit greatly from the implementation of custom
stateful agorithms~\cite{201559}. Such performance gains are not feasable for
the majority of developers, as the difficulty of checking the correctness of
their systems remains high.

Static and dynamic analysis are common approches for building correct
distributed systems. Languages such as TLA+ and
COQ~\cite{specifying-and-verifying-systems-with-tla,
Corbineau:2007:DLC:1786134.1786139} are usefully for specifying systems, and
use model checkers to ensure that safty and liveness properties are not
violated. These checkers require extreme ammounts of computation to check and
the matenice of a fully flushed out specification, in addition to a complete
implmenentation. and the gap between specification, and implementation still
admit bugs. Dynamic model checking techniques check implementations by
systematically exercising a system, or replaying known
faults~\cite{scottminimizing,yang_modist_nsdi09}. While these approaches are
less costly computationally, they represent a strict under aproximation of the
systems behavour.

In this work we propose a dynamic analysis technique which uses logs to reach
safty violating states not reached during execution. Our technique uses the
logs generated from many executions of a system and composes an aggregate state
machine of a single aggregate process, which summerizes all logged behaviour. A
runtime enviornment replicates these machines, and systematically steps through
state transitions. User specified safty and liveness conditions are checked
during simulation. Violations, and their corresponding simulated traces are
output to the user.

Our state machine aggregation algorithm builds on one fundemintal observation -
If the logged state of any two processes match exactly, then their states are
the same. Our state machines are built by finding all occurances of matching
state from all processes on all executions, and overlaying their individual
state machines. The same matching rule is applied to messages, and local events
which trigger state transitions. Using exact state matching, distributed states
not reached during exection can be observerd through simulation, further all
viloations are real bugs.

Our exact state matching algorithm is the extension of theroretical
literature~\cite{Garg:2014:MAS:2580115.2580404}. While correct these conditions
are rarely met in practice, for instance ip port combinations alone fragment an
aggregate state machine into a sparse graph closely resembling traces
themselvles. To apply our analysis in practice we extend our notion of exact
state matching to relaxed state matching, where the logged states of proccesses
represent the same state in our model if a subset of their states match
exactly. This relaxation of state matching collapses the size of a state
machine, but overaproximates state transitions, thereby permiting false
positives.

We propose an additional analysis procedure to order violations flaged using
relaxed state matchingm, by their lieklyhood to be real violations. Prior to
simulation data invariants are collected on state traces on variables which do
not exactly match. Transitions between states on non matching variables are
aproximated using program synthesis. During simulation non matching variables
are aproximated by applying opertations generated by the synthesized
transition. Traces generated which violated the minimal number of invariants
are reported to the user, as they are least likely to have diverged from the
systems constrained behavour.

The rest of the paper is arraged as follows. Section~\ref{sec:model} Defines
our model of a distributed system, and FSM construction.
Section~\ref{sec:system} describes our system. Sections
~\ref{sec:evaluation,sec:timeline} outline a proposed evalutation, and
timeline.
